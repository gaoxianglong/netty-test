ChannelHandler的生命周期
handleradd、handlerremove；

资源泄露的处理
-Dio.netty.leakDetectionLevel=PARANOID，开启泄露检测
针对出入站数据，我们可以选择手动的在最后处理的handler处调用ReferenceCountUtil.release(msg)释放bytebuf，或者针对入站请求，
如果不存在向下一个ChannelHandler传递的诉求，可以使用SimpleChannelInboundHandler#channelRead0，目标方法会自动释放，而
出站数据如果正常写入或者channel关闭时会自动释放资源。

ChannelPipoline
ChannelPipoline的实现是一个链表，用于添加ChannelHandlers，并在链表上传递出入站事件流，每一个新的channel被创建的时候，都会
为其分配一个ChannelPipoline，在channel的整个生命周期中，都将会与同一个ChannelPipoline绑定。
我们可以在ChannelHandler中动态对pipoline进行修改，调整ChannelHandler的生命周期（handleradd、handlerremove）;

ChannelHandlercontext
ChannelHandler上下文，管理它所关联的ChannelHandler和在同一个ChannelPipoline中的其它ChannelHandlers的交互；
每当有ChannelHandler被添加到pipoline中时，就会为ChannelHandler分配一个对应的ChannelHandlercontext；
入站数据从链表头开始传播，出站事件则从链表尾开始传播；链表头是入站的第一个inhandler，链表尾是出站的第一个outhandler

注意：
ChannelHandlerContext的一些方法也存在与Channel和Pipoline上，但Channel和Pipoline会沿着整个链表进行传播，从Pipoline
的第一个ChannelHandler开始，如果不进行特殊处理，将会形成死循环；而ChannelHandlerContext可以产生更短的事件流，可以获得更好的性能，
我们可以通过指定ChannelHandlerContext在下一个ChannelHandler或者指定的Handler上进行事件传播。

总结：
当Channel被创建的时候，会被绑定到一个ChannelPipoline上，ChannelPipoline会添加所有的ChannelHandlers，并且当ChannelHandler被
添加到Pipoline上时将会创建与Handler对应的ChannelHandlerContext；

