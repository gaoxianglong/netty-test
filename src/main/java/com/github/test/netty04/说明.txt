ChannelHandler的生命周期
handleradd、handlerremove；

资源泄露的处理
-Dio.netty.leakDetectionLevel=PARANOID，开启泄露检测
针对出入站数据，我们可以选择手动的在最后处理的handler处调用ReferenceCountUtil.release(msg)释放bytebuf，或者针对入站请求，
如果不存在向下一个channelhandler传递的诉求，可以使用SimpleChannelInboundHandler#channelRead0，目标方法会自动释放，而
出站数据如果正常写入或者channel关闭时会自动释放资源。

channelpipoline
channelpipoline的实现是一个链表，用于添加channelhandlers，并在链表上传递出入站事件流，每一个新的channel被创建的时候，都会
为其分配一个channelpipoline，在channel的整个生命周期中，都将会与同一个channelpipoline绑定。
我们可以在channelhandler中动态对pipoline进行修改，调整channelhandler的生命周期（handleradd、handlerremove）;
channelpipoline的fireXXX和一些出站方法（write）都会将消息传递给下一个channelhandler；

channelhandlercontext
channelhandler上下文，管理它所关联的channelhandler和在同一个channelpipoline中的其它channelhandlers的交互；
每当有channelhandler被添加到pipoline中时，就会为channelhandler分配一个对应的channelhandlercontext；
入站数据从链表头开始传播，出站事件则从链表尾开始传播；链表头是入站的第一个inhandler，链表尾是出站的第一个outhandler

